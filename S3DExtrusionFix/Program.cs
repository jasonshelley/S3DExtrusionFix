using JSo.GCode;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace S3DExtrusionFix
{
    class Program
    {
        const string FilamentDiameter = "filamentDiameters";
        const string NozzleDiameter = "extruderDiameter";
        const string LayerHeight = "layerHeight";
        const string LineWidth = "extruderWidth";
        const string MaxWidthPercentage = "singleExtrusionMaxPrintingWidthPercentage";
        const string FirstLayerWidthPercentage = "firstLayerWidthPercentage";
        const string ExtrusionMultiplier = "extrusionMultiplier";
        const string DefaultSpeed = "defaultSpeed";
        const string FirstLayerUnderSpeed = "firstLayerUnderspeed";
        const string IsParam = "isParam";
        const string IsFeature = "isFeature";
        const string IsLayer = "isLayer";

        private static StreamWriter _log;

        static string _curFeature;
        static Dictionary<string, double> _parameters;


        static void Main(string[] args)
        {
            if (!args.Any())
            {
                Console.WriteLine("The path to the gcode file to be fixed is required.");
                Console.ReadLine();
                return;
            }

            var path = args[0];

            var dir = Directory.Exists(path) ? path : Path.GetDirectoryName(path);
            var logPath = $"{dir}\\S3DExtrusionFix.log";
            var logStream = File.Open(logPath, FileMode.Append, FileAccess.Write);
            _log = new StreamWriter(logStream);
            _log.AutoFlush = true;

            WriteLine($"Processing");

            if (Directory.Exists(path))
            {
                // process entire directory
                var files = Directory.GetFiles(path, "*.gcode");
                files.ToList().ForEach(f =>
                {
                    if (!f.Contains("s3dfix"))
                        ProcessGcode(f, dir);
                });
            }
            else
            {
                ProcessGcode(path, dir);
            }

            _log.Close();
        }

        private static void ProcessGcode(string path, string dir)
        {
            _parameters = new Dictionary<string, double>();

            var lines = File.ReadAllLines(path);

            var gcodeLines = GcodeUtils.ParseLines(lines);


            var movements = new List<(int lineNumber, double lineWidth, double distance, double previousE)>();
            var multiplier = 1.0;

            var maxWidthPercentage = gcodeLines.FirstOrDefault(l => l.LineType == GCodeLineType.S3DSetting && l.S3DSetting.Key == MaxWidthPercentage);
            var firstLayerWidthPercentage = gcodeLines.FirstOrDefault(l => l.LineType == GCodeLineType.S3DSetting && l.S3DSetting.Key == FirstLayerWidthPercentage);

            if (!lines[0].StartsWith("; G-Code generated by Simplify3D(R)"))
            {
                WriteLine("Gcode not generated by Simplify3D");
                return;
            }

            double curx = 0, cury = 0, cure = 0, curz = 0, curlayer = 0;

            var values = new Dictionary<string, double>();

            int lineCount = 0;
            int previousLineNumber = 0;

            var outlines = new List<string>();

            WriteLine(path);

            int outliers = 0;

            foreach (var line in lines)
            {
                lineCount++;
                var outLine = line;
                values = ParseLine(line);
                if (values.ContainsKey(IsParam))
                {
                    values.Remove(IsParam);
                    _parameters.Add(values.Keys.First(), values.Values.First());

                    if (_parameters.ContainsKey(MaxWidthPercentage) && _parameters.ContainsKey(FirstLayerWidthPercentage))
                    {
                        multiplier = Math.Max(_parameters[MaxWidthPercentage], _parameters[FirstLayerWidthPercentage]) / 100.0;
                    }
                } else if (values.ContainsKey(IsFeature))
                {
                    values.Remove(IsFeature);
                    _curFeature = _parameters.Keys.First();
                }
                else if (values.ContainsKey(IsLayer))
                {
                    curlayer = values["Z"];
                }
                else if (values.ContainsKey("G"))
                {
                    switch (values["G"])
                    {
                        case 92:
                            cure = values["E"];
                            break;

                        case 28:
                            curx = cury = 0;
                            curz = 0;
                            break;

                        case 1:
                            var travel = 0.0;
                            if (values.ContainsKey("Z"))
                            {
                                if (values["Z"] == _parameters[LayerHeight])
                                    curlayer = _parameters[LayerHeight];
                                curz = values["Z"];
                            }
                            if (values.ContainsKey("X") && values.ContainsKey("Y"))
                            {
                                var dx = values["X"] - curx;
                                var dy = values["Y"] - cury;
                                travel = Math.Sqrt(dx * dx + dy * dy);

                                curx = values["X"];
                                cury = values["Y"];
                            }
                            if (values.ContainsKey("E"))
                            {
                                var de = values["E"] - cure;
                                // volume extruded
                                var extrudedVolume = de * Math.PI * Math.Pow(_parameters[FilamentDiameter] / 2, 2);

                                if (travel != 0)
                                {
                                    // for a given volume extruded, for a given distance
                                    // we can calculate the actual line width
                                    // width = volume / (dd * layer height)
                                    double lineWidth = extrudedVolume / (travel * curlayer);
                                    // line width is greater than the indicated maximums
                                    if (lineWidth > _parameters[LineWidth] * multiplier)
                                    {
                                        // we'll set the new extrusion to achieve the configured line width
                                        // this may be wrong as it may be a single line extrusion
                                        // TODO: Deal with single line extrusions
                                        var volumeToExtrude = travel * _parameters[LineWidth] * curlayer * _parameters[ExtrusionMultiplier] * multiplier;
                                        var extrusionDistance = volumeToExtrude / (Math.PI * Math.Pow(_parameters[FilamentDiameter] / 2, 2));

                                        values["E"] = cure + extrusionDistance;

                                        outLine = BuildNewLine(values);

                                        if (lineCount == previousLineNumber + 1)
                                        {
                                            Write(".");
                                        }
                                        else
                                        {
                                            outliers++;
                                            if (previousLineNumber != 0)
                                                WriteLine();
                                            Write($"({(lineCount == previousLineNumber + 1 ? "+" : "")}{lineCount}) Line Width: {lineWidth} Cross Sectional Area:{_parameters[LayerHeight] * lineWidth}");
                                        }

                                        previousLineNumber = lineCount;
                                    }
                                    movements.Add((lineCount, lineWidth, travel, cure));
                                }
                                cure = values["E"];
                            }


                            break;
                    }
                }
                outlines.Add(outLine);
            }

            var mean = movements.Average(m => m.lineWidth);
            var sd = Sd(movements.Select(m => m.lineWidth));

            if (outliers == 0)
            {
                WriteLine("Clean file. No action taken.");
                return;
            }

            WriteLine();
            WriteLine($"Configured line width (including extrusion multiplier): {_parameters[LineWidth] * _parameters[ExtrusionMultiplier]}");
            WriteLine($"Mean line width: {mean}");
            WriteLine($"Std: {sd}");
            WriteLine($"Total outliers: {outliers}");

            var filename = Path.GetFileNameWithoutExtension(path);
            var extension = Path.GetExtension(path);

            var newFilename = $"{dir}\\{filename}.s3dfix{extension}";

            File.WriteAllLines(newFilename, outlines);

            WriteLine($"Fixes written to: {newFilename}");
        }

        private static void Write(string msg)
        {
            _log.Write(msg);
            Console.Write(msg);
        }
        private static void WriteLine(string msg = null)
        {
            if (string.IsNullOrEmpty(msg))
            {
                _log.WriteLine();
                Console.WriteLine();
            }
            else
            {
                _log.WriteLine($"{DateTime.Now} - {msg}");
                Console.WriteLine(msg);
            }
        }

        private static string BuildNewLine(Dictionary<string, double> tags)
        {
            var bob = new StringBuilder();
            bob.Append($"G{tags["G"]:0} X{tags["X"]:0.000} Y{tags["Y"]:0.000} E{tags["E"]:0.0000}");

            if (tags.ContainsKey("F"))
            {
                // HACK: No config or arguments
                if (_curFeature == "solid layer") {
                    // use first layer speed for any solid layer
                    var newF = (int)(_parameters[DefaultSpeed] * _parameters[FirstLayerUnderSpeed]);
                }
                bob.Append($" F{tags["F"]:0}");
            }

            var newLine = bob.ToString();
            return newLine;
        }

        static double Sd(IEnumerable<double> values)
        {
            var mean = values.Average();

            var sumOfSquares = values.Sum(v => (v - mean) * (v - mean));

            var sd = Math.Sqrt(sumOfSquares / (values.Count() - 1));

            return sd;
        }

        static Dictionary<string, double> ParseLine(string line)
        {
            var values = new Dictionary<string, double>();
            if (line.StartsWith(";"))
            {
                line = line.Substring(2);
                if (line.StartsWith("layer") && !line.Equals("layer end"))
                {
                    values.Add(IsLayer, 0);
                    var parts = line.Split(',');
                    var height = parts[1].Split('=')[1].Trim();
                    values.Add("Z", double.Parse(height));
                }
                else if (line.StartsWith("feature"))
                {
                    values.Add(IsFeature, 0);
                    values.Add(line.Substring("feature".Length), 0);
                }
                else if (line.StartsWith("  "))
                {
                    line = line.Substring(2);
                    var parts = line.Split(',');
                    if (parts.Count() > 1)
                    {
                        var valueArray = parts[1]?.Split('|');
                        if (double.TryParse(valueArray[0], out var x))
                        {
                            values.Add(IsParam, 0);
                            values.Add(parts[0], x);
                        }
                    }
                }
            }
            else if (!string.IsNullOrEmpty(line))
            {

                var isParam = new Regex(@"[A-Z][0-9\.]+");
                var parts = line.Split(' ');
                if (parts[0][0] == 'G')
                {
                    foreach (var part in parts)
                    {
                        if (isParam.IsMatch(part))
                        {
                            var tag = part[0];
                            if (double.TryParse(part.Substring(1, part.Length - 1), out var v))
                                values.Add(new String(tag, 1), v);
                        }
                    }
                }

            }
            return values;
        }
    }
}
